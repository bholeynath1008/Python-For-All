### 1. Accessing and Slicing Tuples
**Note:** Slicing and indexing work exactly like lists.

```python
# Basic Accessing
numbers = (10, 20, 3, 205)
print("Element at index 2:", numbers[2])

# Last three numbers (Negative Slicing)
print("Last 3 numbers:", numbers[-3:])

# Step by 2 (Alternative slicing syntax)
t = (5, 6, 8, 9, 10, 23, 56, 86)
print("Every 2nd element:", t[::2])

# Access first 3 elements
t_long = (1, 7, 4, 9, 8, 9, 55, 994)
print("First 3 elements:", t_long[:3])  # Stop at index 3 (exclusive)
```

---

### 2. Tuple Operations (Join, Repeat, Length)
**Method A:** Concatenation (`+`) creates a new tuple.
**Method B:** Unpacking (`*`) works in Python 3.5+.

```python
t1 = (10, 20, 3, 205)
t2 = (1000, 3000)

# Method A: Using + operator
joined_a = t1 + t2
print("Joined A:", joined_a)

# Method B: Using unpacking (creates a new tuple)
joined_b = (*t1, *t2)
print("Joined B:", joined_b)

# Repeat tuple 3 times
repeated = t1 * 3
print("Repeated:", repeated)

# Length of tuple
print("Length of t1:", len(t1))
```

---

### 3. Searching and Checking Existence

```python
data = (10, 20, 3, 205)

# Check if 3 exists
print("Is 3 in tuple?", 3 in data)

# Find index of 20
# Method A: Direct (Throws ValueError if not found)
index = data.index(20)
print("Index of 20:", index)

# Method B: Safe Check (Doesn't throw error)
target = 50
if target in data:
    print(f"Index of {target}:", data.index(target))
else:
    print(f"{target} not found in tuple.")
```

---

### 4. Modifying Tuples (Immutability Workarounds)
**Important:** Tuples are immutable. To "modify" them, you must create a **new tuple**.

```python
# Replace first element with 99
t = (5, 6, 8, 9, 10, 23, 56, 86)

# Logic: (New Element,) + (Rest of original tuple)
new_t = (99,) + t[1:]
print("New tuple with replaced first element:", new_t)

# Add a single integer x to a tuple
# Note: You must use (x,) to indicate it is a tuple, not just a bracketed math operation
x = 99
t_new = t + (x,)
print("Tuple after adding integer:", t_new)
```

---

### 5. Joining with a Middle Value
**Task:** Join tuple `a`, value `x`, and tuple `b`.

```python
a = (1, 2)
b = (4, 5)
x = 7

# Convert x to a single-element tuple (x,) and concatenate
result = a + (x,) + b
print("Joined with middle value:", result)

# Alternatively using unpacking
result_unpack = (*a, x, *b)
print("Joined using unpacking:", result_unpack)
```

---

### 6. Sorting and Reversing
Since tuples are immutable, `sort()` (which modifies in-place) doesn't exist. We use `sorted()`.

```python
nums = (1, 7, 4, 9, 8)

# Reverse a tuple (using slicing)
reversed_t = nums[::-1]
print("Reversed tuple:", reversed_t)

# Sort a tuple (returns a list)
sorted_list = sorted(nums)
print("Sorted as list:", sorted_list)

# Sort a tuple (returns a tuple)
sorted_tuple = tuple(sorted(nums))
print("Sorted as tuple:", sorted_tuple)

# Find maximum value without converting to list
# max() works natively on tuples
print("Maximum value:", max(nums))
print("Minimum value:", min(nums))
```

---

### 7. Nested Tuples (Accessing Inner Data)
**Correction:** Nested tuples must be separated by commas.

```python
# 1. Nested tuple of strings
animals = ("dog", "cat") # Input had [] brackets, corrected to ()
print("First char of first item:", animals[0][0]) 

# 2. Access number 4 from nested tuple
# Corrected syntax: ((1,2), (3,4))
coords = ((1, 2), (3, 4))
print("Access number 4:", coords[1][1])

# 3. Access last value of deeper nested tuple
# Corrected syntax: ((1,2), (3,4,6))
deep = ((1, 2), (3, 4, 6))
# Access second group (index 1), then last item (index -1)
print("Last value of nested tuple:", deep[1][-1])
```

---

### 8. Syntax Differences
**With vs Without Brackets:**
Both are tuples. Python treats commas as the primary separator for tuples.

```python
# Without brackets (Packing)
x = 2, 3
print(f"Value: {x}, Type: {type(x)}")

# With brackets (Explicit Tuple)
y = (2, 4)
print(f"Value: {y}, Type: {type(y)}")

# Edge case: Single element tuple MUST have a comma
z = (1,)    # This is a tuple
w = (1)     # This is an integer
print(f"z is tuple: {isinstance(z, tuple)}")
print(f"w is tuple: {isinstance(w, tuple)}")
```
