

Here is the categorized, corrected, and improved version of your Python list code. I have used better variable names (e.g., `numbers`, `fruits`, `letters`) and fixed logical errors, particularly in the variable swapping section.

### 1. Accessing Elements (Slicing & Indexing)
**Corrected Variable Name:** `numbers`

```python
numbers = [108, 28, 560, 40, 50]

# 1. Print the 2nd and 4th number (Indices 1 and 3)
# Method A: Direct access
print("2nd and 4th number:", numbers[1], numbers[3])

# Method B: Slicing (start at index 1, stop at index 4, step 2)
print("Using slice [1:4:2]:", numbers[1:4:2])

# 2. Get the last 3 numbers (start to end)
print("Last 3 numbers:", numbers[-3:])

# 3. Get the last 4 numbers step by 2
# Note: List has 5 items. Last 4 are indices 1,2,3,4. Step 2 gets index 1 and 3.
print("Last 4 numbers step by 2:", numbers[-4::2])
```

---

### 2. Basic Statistics
**Corrected Variable Name:** `data`

```python
data = [108, 28, 560, 40, 50]

print("Length:", len(data))
print("Maximum:", max(data))
print("Minimum:", min(data))
```

---

### 3. Sorting Lists
**Corrected Variable Names:** `nums`, `vowels`

```python
# Sort numbers
nums = [10, 80, 30, 40, 50]
nums.sort()
print("Sorted numbers:", nums)

# Sort letters (ascending)
vowels = ['a', 'u', 'i', 'e', 'o']
vowels.sort()
print("Sorted letters:", vowels)

# Sort letters (descending/reverse)
vowels.sort(reverse=True)
print("Reverse sorted letters:", vowels)
```

---

### 4. Finding Data
**Corrected Variable Name:** `chars`

```python
chars = ['a', 'u', 'i', 'e', 'o', 'a']
count = chars.count('a')
print("Count of 'a':", count)
```

---

### 5. Modifying Elements (Swapping)
**Corrected Logic:** The original code overwrote the value before swapping it. The Pythonic way uses tuple unpacking.

```python
# Swap first and last element in a list
items = ['apple', 'ball', 'cat', 'dog']

# Correct way to swap without losing data
items[0], items[-1] = items[-1], items[0]
print("After swapping first and last:", items)

# --- SWAPPING VARIABLES (Not list elements) ---
list_a = ['a', 'u', 'i', 'e', 'o', 'a']
list_b = ['k', 'a']

# Swap the variables list_a and list_b
list_a, list_b = list_b, list_a

print("list_a after swap:", list_a)
print("list_b after swap:", list_b)
```

---

### 6. Adding and Removing Elements
**Corrected Variable Name:** `fruits`

```python
fruits = ['apple', 'ball', 'cat', 'dog']

# Add single element
fruits.append("blue")
print("After append:", fruits)

# Add multiple elements
fruits.extend(["mango", "grape"]) # better than individual appends
print("After extend:", fruits)

# Remove specific element by value
fruits.remove("ball")
print("After remove 'ball':", fruits)

# Remove last element (pop)
removed_item = fruits.pop()
print(f"Popped item: {removed_item}, List: {fruits}")
```

---

### 7. Merging Lists
**Corrected Variable Names:** `list1`, `list2`

```python
list1 = ['apple', 'ball', 'cat', 'dog']
list2 = ['man', 'pink']

# Method 1: Concatenation
merged_list = list1 + list2

# Method 2: Sorting the merged result
sorted_items = sorted(merged_list) # sorted() returns a new list, doesn't change original
print("Sorted merged list:", sorted_items)

# Program to merge two SORTED lists into a single sorted list efficiently
sorted_a = [10, 20, 50]
sorted_b = [5, 15, 60]

# Simple Pythonic way:
single_sorted = sorted(sorted_a + sorted_b)
print("Merged sorted:", single_sorted)
```

---

### 8. Unique Values & Reversing

```python
# Get unique values from a list
dup_list = [1, 2, 2, 3, 4, 4, 5]
unique_list = list(set(dup_list))
print("Unique values:", unique_list)

# Reverse a list
# Method A: Using slicing (creates a new list)
original = [10, 20, 30]
reversed_slice = original[::-1]
print("Reversed via slicing:", reversed_slice)

# Method B: Using .reverse() method (modifies in-place)
original.reverse()
print("Reversed via method:", original)
```

---

### 9. Deep Copy vs Shallow Copy
**Check ID:** `id()` prints the memory address.

```python
import copy

original = [[1, 2], [3, 4]]

# Shallow Copy: Creates new list, but elements are references to the same objects
shallow = original.copy()

# Deep Copy: Creates new list and recursively adds copies of found objects
deep = copy.deepcopy(original)

# Check IDs
print("ID of Original:", id(original))
print("ID of Shallow:", id(shallow))  # Different ID from original
print("ID of Deep:", id(deep))        # Different ID from original

# The difference shows when modifying nested items:
shallow[0][0] = 99
deep[0][0] = 88

print("Original after modifying shallow copy:", original) # Changes because of shallow copy
print("Deep copy after modification:", deep)             # Unchanged
```

---

### 10. Iteration in Lists
There are two main ways to iterate over a list.

```python
data = [10, 20, 30, 40]

# Type 1: Direct Iteration (Best for reading values)
print("Direct Iteration:")
for item in data:
    print(item)

# Type 2: Index Iteration (Best if you need the index)
print("\nIndex Iteration:")
for index in range(len(data)):
    print(f"Index {index}: {data[index]}")

# Type 3: Enumerate (Best of both worlds - gives index and value)
print("\nEnumerate Iteration:")
for i, value in enumerate(data):
    print(f"Index {i}: {value}")
```
