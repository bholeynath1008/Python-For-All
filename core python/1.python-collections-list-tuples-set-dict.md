# Python Collections: Complete Reference Guide

## üìë Table of Contents

1. [Quick Comparison Table](#-quick-comparison-table)
2. [Summary & Best Practices](#-summary-&-best-practices)
3. [Lists `[]` - Mutable, Ordered](#1Ô∏è‚É£-lists---mutable-ordered)
   - Syntax & Operations
   - Real-World Use Cases
   - Key Rules & Best Practices
4. [Tuples `()` - Immutable, Ordered](#2Ô∏è‚É£-tuples---immutable-ordered)
   - Syntax & Operations
   - Real-World Use Cases
   - Key Rules & Best Practices
5. [Sets `{}` - Mutable, Unordered, Unique](#3Ô∏è‚É£-sets---mutable-unordered-unique)
   - Syntax & Operations
   - Real-World Use Cases
   - Key Rules & Best Practices
6. [Dictionaries `{}` - Key-Value Pairs](#4Ô∏è‚É£-dictionaries---key-value-pairs)
   - Syntax & Operations
   - Real-World Use Cases
   - Key Rules & Best Practices
7. [Type Casting Between Collections](#-type-casting-between-collections)
   - All Conversion Possibilities
   - When to Convert
   - Common Patterns
8. [When to Use Which Collection](#-when-to-use-which-collection)
9. [Quick Syntax Reference](#-quick-syntax-reference)

---
### Key Takeaways

*Data Structures (List, Tuple, Set, Dictionary)*
- **List[]**: `Ordered`, `Mutable`, `Duplicates`
- **Tuple()**: `Ordered`, `Immutable`, `Duplicates`
- **Set{}**:`Unordered`(No Indexing), `Mutable`, `Unique` only, unhassable(stores immutable only)
- **Dictionary{:}**: `Ordered`, `Mutable`, `Key` should be `Unique`, If duplicate key replace previous one
- 
### Conversions- type casting
*Note*: if `list({"a": 1, "b": 2})`, `tuple(dict)`, `set(dict)`, it will take `keys` only ie. ['a','b']
```python
list(x)                # ‚Üí List
tuple(x)               # ‚Üí Tuple
set(x)                 # ‚Üí Set
dict(x)                # ‚Üí Dict (needs pairs)
```
## üìä Quick Comparison Table

| Feature | List `[]` | Tuple `()` | Set `{}` | Dictionary `{}` |
|---------|-----------|------------|----------|-----------------|
| **Empty creation** | `l = []` or `list()` | `t = ()` or `tuple()` | `s = set()` | `d = {}` or `dict()` |
| **Print empty** | `[]` | `()` | `set()` | `{}` |
| **With values** | `[1, 2, 3]` | `(1, 2, 3)` | `{1, 2, 3}` | `{"a": 1, "b": 2}` |
| **Structure** | Values only | Values only | Unique values | Key-value pairs |
| **Order preserved** | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes (Python 3.7+) |
| **Indexing** | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes (by key) |
| **Slicing** | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No | ‚ùå No |
| **Duplicates** | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No | ‚ùå No (keys) |
| **Mutable** | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes |
| **Allowed types** | Any | Any | Immutable only, doesn't store list and mutable, TypeError: unhashable type: 'list' ie.hashable means mutable  | Keys: Immutable<br>Values: Any |
| | | | | |
| **üìñ EXTRACT/READ** | | | | |
| By index/key | `l[0]` first<br>`l[-1]` last | `t[0]` first<br>`t[-1]` last | ‚ùå Not possible | `d["key"]`<br>`d.get("key")` |
| Slicing | `l[1:3]`<br>`l[::2]` | `t[1:3]`<br>`t[::2]` | ‚ùå Not possible | ‚ùå Not possible |
| Check existence | `item in l` | `item in t` | `item in s` (fast) | `key in d` (fast) |
| Get all items | `l` (all values) | `t` (all values) | `s` (all values) | `d.items()` (pairs)<br>`d.keys()` (keys)<br>`d.values()` (values) |
| | | | | |
| **‚ûï ADD ELEMENTS** | | | | |
| Add one | `l.append(5)` (end)<br>`l.insert(2, 5)` (index) | ‚ùå Immutable | `s.add(5)` | `d["key"] = value`<br>`d.update({"key": v})` |
| Add multiple | `l.extend([5, 6])`<br>`l += [5, 6]` | ‚ùå Immutable | `s.update([5, 6, 7])`<br>`s.update({5, 6})` | `d.update({"k1": 1, "k2": 2})` |
| | | | | |
| **‚úèÔ∏è MODIFY/REPLACE** | | | | |
| Replace one | `l[0] = 10`<br>`l[-1] = 20` | ‚ùå Immutable | ‚ùå Not possible<br>(remove & add) | `d["key"] = new_value` |
| Replace multiple | `l[1:3] = [10, 20]` ie. Remove/slice index 1 and 2 & replace, 3 exclusive | ‚ùå Immutable | ‚ùå Not possible | `d.update({"k1": 10, "k2": 20})` |
| | | | | |
| **üóëÔ∏è REMOVE ELEMENTS** | | | | |
| Remove by value | `l.remove(5)` (first)<br>‚ö†Ô∏è ValueError if missing | ‚ùå Immutable | `s.remove(5)` ‚ö†Ô∏è KeyError<br>`s.discard(5)` ‚úÖ Safe | ‚ùå Not applicable |
| Remove by index/key | `l.pop(0)` (returns)<br>`del l[0]` | ‚ùå Immutable | `s.pop()` (arbitrary) | `d.pop("key")` (returns)<br>`del d["key"]` |
| Remove last | `l.pop()` | ‚ùå Immutable | `s.pop()` (arbitrary) | `d.popitem()` (last pair) |
| Remove all | `l.clear()` ‚Üí `[]` | ‚ùå Immutable | `s.clear()` ‚Üí `set()` | `d.clear()` ‚Üí `{}` |
| Delete variable | `del l` | `del t` | `del s` | `del d` |
| | | | | |
| **üîß OTHER OPERATIONS** | | | | |
| Length | `len(l)` | `len(t)` | `len(s)` | `len(d)` (keys) |
| Count occurrences | `l.count(5)` | `t.count(5)` | ‚ùå (always 0 or 1) | ‚ùå (keys unique) |
| Find index | `l.index(5)` | `t.index(5)` | ‚ùå Not possible | ‚ùå Not possible |
| Sort | `l.sort()` in-place<br>`sorted(l)` new | `sorted(t)` ‚Üí list | `sorted(s)` ‚Üí list | `sorted(d)` keys<br>`sorted(d.items())` |
| Reverse | `l.reverse()` in-place<br>`l[::-1]` new | `t[::-1]` new tuple | ‚ùå Not ordered | ‚ùå Not typical |
| Copy | `l.copy()`<br>`l[:]` | `t` (immutable) | `s.copy()` | `d.copy()` |
| Concatenate | `l1 + l2` new<br>`l1.extend(l2)` modify | `t1 + t2` new | `s1 \| s2` union<br>`s1.union(s2)` | `d1 \| d2` (Py 3.9+)<br>`d1.update(d2)` |

---
## üéì Summary & Best Practices
### Common Mistakes to Avoid

‚ùå Using `{}` for empty set (it's a dict!)
‚ùå Trying to modify tuples
‚ùå Putting mutable types in sets
‚ùå Using mutable types as dict keys
‚ùå Forgetting that sets are unordered
‚ùå Using `remove()` without checking existence

### Best Practices

‚úÖ Use `list` for sequences that change
‚úÖ Use `tuple` for fixed data and function returns
‚úÖ Use `set` for uniqueness and fast lookups
‚úÖ Use `dict` for structured data with named fields
‚úÖ Use `get()` with dicts to avoid KeyErrors
‚úÖ Use `discard()` with sets to avoid KeyErrors
‚úÖ Convert to set to remove duplicates
‚úÖ Use comprehensions for transformations
‚úÖ Choose the right collection for your use case

## 1Ô∏è‚É£ LISTS `[]` - Mutable, Ordered

### üìñ Syntax & Operations

#### Extract/Read
```python
l = [10, 20, 30, 40, 50]

# Single element
l[0]           # 10 (first)
l[-1]          # 50 (last)
l[2]           # 30 (third)

# Slicing
l[1:4]         # [20, 30, 40]
l[:3]          # [10, 20, 30] (first 3)
l[2:]          # [30, 40, 50] (from index 2)
l[::2]         # [10, 30, 50] (every 2nd)
l[::-1]        # [50, 40, 30, 20, 10] (reverse)

# Check existence
20 in l        # True
60 in l        # False
```

#### ‚ûï Add
```python
l = [10, 20, 30]

# Add one element
l.append(40)           # [10, 20, 30, 40] (at end)
l.insert(1, 15)        # [10, 15, 20, 30, 40] (at index 1)

# Add multiple elements
l.extend([50, 60])     # [10, 15, 20, 30, 40, 50, 60]
l += [70, 80]          # [10, 15, 20, 30, 40, 50, 60, 70, 80]
l[2:2] = [25, 26]      # Insert multiple at position 2
```

#### ‚úèÔ∏è Modify/Replace
```python
l = [10, 20, 30, 40, 50]

# Replace one
l[0] = 100             # [100, 20, 30, 40, 50]
l[-1] = 500            # [100, 20, 30, 40, 500]

# Replace multiple (slice assignment)
l[1:3] = [200, 300]    # [100, 200, 300, 40, 500]
l[1:4] = [999]         # [100, 999, 500] (replaces 3 with 1)
```

#### üóëÔ∏è Remove
```python
l = [10, 20, 30, 20, 40]

# Remove by value
l.remove(20)           # [10, 30, 20, 40] (removes first 20 only)

# Remove by index
l.pop(0)               # Removes 10, returns 10 ‚Üí [30, 20, 40]
l.pop()                # Removes 40, returns 40 ‚Üí [30, 20]
del l[0]               # Removes 30 ‚Üí [20]

# Remove multiple by slice
l = [1, 2, 3, 4, 5]
del l[1:3]             # [1, 4, 5]

# Remove all
l.clear()              # []
```

#### üîß Other Operations
```python
l = [3, 1, 4, 1, 5, 9, 2]

# Sort
l.sort()               # [1, 1, 2, 3, 4, 5, 9] (in-place)
l.sort(reverse=True)   # [9, 5, 4, 3, 2, 1, 1] (descending)
new_l = sorted(l)      # Returns new sorted list

# Reverse
l.reverse()            # In-place reverse
new_l = l[::-1]        # Returns new reversed list

# Count & Find
l.count(1)             # 2 (occurrences)
l.index(4)             # 2 (first index, ValueError if not found)

# Copy
l2 = l.copy()          # Shallow copy
l3 = l[:]              # Shallow copy (alternative)

# Concatenate
l1 = [1, 2]
l2 = [3, 4]
l3 = l1 + l2           # [1, 2, 3, 4] (new list)
l1.extend(l2)          # l1 becomes [1, 2, 3, 4] (modifies l1)
```

### üéØ Real-World Use Cases

#### 1. Shopping Cart
```python
cart = []
cart.append("Laptop")
cart.append("Mouse")
cart.append("Keyboard")
cart.remove("Mouse")
print(f"Total items: {len(cart)}")  # 2
```

#### 2. Student Grades (with order)
```python
grades = [85, 92, 78, 95, 88]
grades.append(90)          # Add new grade
grades.sort(reverse=True)  # Highest first
average = sum(grades) / len(grades)
print(f"Top grade: {grades[0]}")
```

#### 3. Task Queue (FIFO - First In First Out)
```python
tasks = ["task1", "task2", "task3"]
tasks.append("task4")      # Add to end
current_task = tasks.pop(0)  # Remove from front
print(f"Processing: {current_task}")
```

#### 4. Browser History
```python
history = []
history.append("google.com")
history.append("github.com")
history.append("stackoverflow.com")
last_page = history[-1]     # Current page
previous = history[-2]      # Go back
```

#### 5. Data Processing Pipeline
```python
data = [1, 2, 3, 4, 5]
# Transform each element
processed = [x * 2 for x in data]  # [2, 4, 6, 8, 10]
# Filter
filtered = [x for x in data if x > 2]  # [3, 4, 5]
```

### üìè Key Rules & Best Practices

‚úÖ **Use Lists When:**
- You need ordered collection with duplicates
- You need to access elements by index
- You need to modify elements frequently
- Order matters (insertion order is preserved)
- You need to sort or reverse data

‚ùå **Avoid Lists When:**
- You need fast membership testing (`in` operator) ‚Üí Use Set
- You need key-value mapping ‚Üí Use Dictionary
- Data should be immutable/protected ‚Üí Use Tuple
- You need unique values only ‚Üí Use Set

‚ö†Ô∏è **Important Rules:**
- Lists are mutable (can be modified)
- Can contain any data type (mixed types allowed)
- Indexing starts at 0
- Negative indexing: -1 is last element
- `remove()` raises ValueError if element not found
- `pop()` without argument removes last element
- Slicing creates a new list

---

## 2Ô∏è‚É£ TUPLES `()` - Immutable, Ordered

### üìñ Syntax & Operations

#### Extract/Read
```python
t = (10, 20, 30, 40, 50)

# Single element
t[0]           # 10
t[-1]          # 50

# Slicing
t[1:4]         # (20, 30, 40)
t[::2]         # (10, 30, 50)

# Check existence
20 in t        # True

# Unpacking
a, b, c = (1, 2, 3)  # a=1, b=2, c=3
x, *y, z = (1, 2, 3, 4, 5)  # x=1, y=[2,3,4], z=5
```

#### ‚ûï Add / ‚úèÔ∏è Modify / üóëÔ∏è Remove
```python
# ‚ùå ALL MODIFICATION OPERATIONS ARE NOT ALLOWED
# Tuples are immutable!

t = (10, 20, 30)
# t.append(40)      # ‚ùå AttributeError
# t[0] = 100        # ‚ùå TypeError
# t.remove(20)      # ‚ùå AttributeError

# ‚úÖ Workarounds (create new tuple):
t = t + (40,)     # (10, 20, 30, 40)
t = (5,) + t      # (5, 10, 20, 30, 40)
```

#### üîß Other Operations
```python
t = (1, 2, 3, 2, 4)

# Count & Find
t.count(2)         # 2 (occurrences)
t.index(3)         # 2 (first index)

# Concatenate
t1 = (1, 2)
t2 = (3, 4)
t3 = t1 + t2       # (1, 2, 3, 4)

# Convert to list for modifications
l = list(t)
l.append(5)
t = tuple(l)       # (1, 2, 3, 2, 4, 5)
```

### üéØ Real-World Use Cases

#### 1. GPS Coordinates (Immutable Position)
```python
location = (37.7749, -122.4194)  # San Francisco
latitude, longitude = location
print(f"Lat: {latitude}, Long: {longitude}")
```

#### 2. RGB Color Values
```python
red = (255, 0, 0)
green = (0, 255, 0)
blue = (0, 0, 255)

def mix_colors(c1, c2):
    return tuple((a + b) // 2 for a, b in zip(c1, c2))

purple = mix_colors(red, blue)  # (127, 0, 127)
```

#### 3. Database Records (Immutable Row)
```python
employee = (101, "John Doe", "Engineering", 75000)
emp_id, name, dept, salary = employee

# Use in database queries
records = [
    (1, "Alice", 25),
    (2, "Bob", 30),
    (3, "Charlie", 35)
]
```

#### 4. Function Return Multiple Values
```python
def get_stats(numbers):
    return min(numbers), max(numbers), sum(numbers)

minimum, maximum, total = get_stats([1, 2, 3, 4, 5])
```

#### 5. Dictionary Keys (Immutable Required)
```python
# Tuples can be dict keys (lists cannot)
locations = {
    (40.7128, -74.0060): "New York",
    (34.0522, -118.2437): "Los Angeles",
    (41.8781, -87.6298): "Chicago"
}

city = locations[(40.7128, -74.0060)]  # "New York"
```

#### 6. Configuration Settings (Read-Only)
```python
# Settings that shouldn't be modified
CONFIG = (
    "localhost",  # host
    8080,         # port
    "admin",      # username
    True          # use_ssl
)

HOST, PORT, USER, SSL = CONFIG
```

### üìè Key Rules & Best Practices

‚úÖ **Use Tuples When:**
- Data should NOT be modified (immutable by design)
- You need to use it as dictionary key
- You want to ensure data integrity
- Returning multiple values from function
- Storing fixed configurations
- Performance matters (faster than lists)

‚ùå **Avoid Tuples When:**
- You need to frequently add/remove elements
- You need to sort or modify data
- You want to use list methods (append, extend, etc.)

‚ö†Ô∏è **Important Rules:**
- Tuples are immutable (cannot be modified after creation)
- Single element tuple requires trailing comma: `(5,)` not `(5)`
- Empty tuple: `()` or `tuple()`
- Can contain any data type (mixed types allowed)
- Can be used as dictionary keys (hashable)
- Faster iteration than lists
- Less memory than lists

---

## 3Ô∏è‚É£ SETS `{}` - Mutable, Unordered, Unique

### üìñ Syntax & Operations

#### Extract/Read
```python
s = {10, 20, 30, 40, 50}

# ‚ùå No indexing/slicing
# s[0]  # TypeError

# Check existence (O(1) - very fast!)
20 in s        # True
60 in s        # False

# Iterate
for item in s:
    print(item)

# Convert to list for indexing
list(s)[0]     # First element (order not guaranteed)
```

#### ‚ûï Add
```python
s = {10, 20, 30}

# Add one element
s.add(40)              # {10, 20, 30, 40}
s.add(20)              # {10, 20, 30, 40} (no duplicate)

# Add multiple elements
s.update([50, 60])     # {10, 20, 30, 40, 50, 60}
s.update({70, 80})     # {10, 20, 30, 40, 50, 60, 70, 80}
s |= {90, 100}         # Union update
```

#### ‚úèÔ∏è Modify/Replace
```python
# ‚ùå Cannot replace directly (no indexing)

# ‚úÖ Workaround: Remove old, add new
s = {10, 20, 30}
if 20 in s:
    s.remove(20)
    s.add(25)          # {10, 25, 30}
```

#### üóëÔ∏è Remove
```python
s = {10, 20, 30, 40, 50}

# Remove by value
s.remove(20)           # {10, 30, 40, 50} ‚ö†Ô∏è KeyError if not found
s.discard(30)          # {10, 40, 50} ‚úÖ No error if not found
s.discard(999)         # No error, set unchanged

# Remove arbitrary element
element = s.pop()      # Removes & returns any element

# Remove all
s.clear()              # set()
```

#### üîß Set Operations
```python
A = {1, 2, 3, 4}
B = {3, 4, 5, 6}

# Union (all unique elements from both)
A.union(B)              # {1, 2, 3, 4, 5, 6}
A | B                   # {1, 2, 3, 4, 5, 6}

# Intersection (common elements)
A.intersection(B)       # {3, 4}
A & B                   # {3, 4}

# Difference (in A but not in B)
A.difference(B)         # {1, 2}
A - B                   # {1, 2}

# Symmetric Difference (in A or B, not both)
A.symmetric_difference(B)  # {1, 2, 5, 6}
A ^ B                   # {1, 2, 5, 6}

# Subset/Superset checks
{1, 2}.issubset(A)      # True
A.issuperset({1, 2})    # True
A.isdisjoint(B)         # False (have common elements)

# Copy
s2 = s.copy()
```

### üéØ Real-World Use Cases

#### 1. Remove Duplicates from List
```python
emails = ["a@x.com", "b@x.com", "a@x.com", "c@x.com"]
unique_emails = list(set(emails))
# ['a@x.com', 'b@x.com', 'c@x.com']
```

#### 2. Check User Permissions
```python
user_permissions = {"read", "write"}
required_permissions = {"read", "write", "execute"}

if required_permissions.issubset(user_permissions):
    print("Access granted")
else:
    missing = required_permissions - user_permissions
    print(f"Missing permissions: {missing}")
    # Missing permissions: {'execute'}
```

#### 3. Find Common Friends (Social Network)
```python
alice_friends = {"Bob", "Charlie", "David"}
bob_friends = {"Alice", "Charlie", "Eve"}

mutual_friends = alice_friends & bob_friends
# {'Charlie'}
```

#### 4. Tag System (Blog/Articles)
```python
post1_tags = {"python", "programming", "tutorial"}
post2_tags = {"python", "web", "flask"}

# All unique tags
all_tags = post1_tags | post2_tags
# {'python', 'programming', 'tutorial', 'web', 'flask'}

# Common tags
common_tags = post1_tags & post2_tags
# {'python'}
```

#### 5. Inventory Management (Track Unique Items)
```python
in_stock = {"laptop", "mouse", "keyboard", "monitor"}
sold_items = {"mouse", "keyboard"}

available = in_stock - sold_items
# {'laptop', 'monitor'}
```

#### 6. Email Validation (Check for Unique Subscribers)
```python
subscribers = set()
subscribers.add("user1@example.com")
subscribers.add("user2@example.com")
subscribers.add("user1@example.com")  # Duplicate ignored
print(len(subscribers))  # 2
```

### üìè Key Rules & Best Practices

‚úÖ **Use Sets When:**
- You need unique values only (no duplicates)
- You need fast membership testing (`in` operator)
- You need mathematical set operations (union, intersection)
- Order doesn't matter
- You want to remove duplicates from a list

‚ùå **Avoid Sets When:**
- You need to maintain order
- You need to access elements by index
- You need to store mutable objects (lists, dicts)
- You need to count occurrences of elements

‚ö†Ô∏è **Important Rules:**
- Sets are unordered (no guaranteed order)
- Only immutable types allowed (int, float, str, bool, tuple)
- Cannot contain lists, sets, or dictionaries
- No duplicates allowed (automatically removed)
- Empty set: `set()` NOT `{}` (that's empty dict)
- Fast O(1) lookup time
- `remove()` raises KeyError, `discard()` doesn't
- `{0, False}` ‚Üí `{0}` (bool False == int 0)
- `{1, True}` ‚Üí `{1}` (bool True == int 1)

---

## 4Ô∏è‚É£ DICTIONARIES `{}` - Key-Value Pairs

### üìñ Syntax & Operations

#### Creation
```python
# Basic creation
d = {"name": "John", "age": 25, "city": "NYC"}
d = {}                          # Empty dict
d = dict()                      # Empty dict

# From list of tuples
d = dict([("a", 1), ("b", 2)])  # {"a": 1, "b": 2}

# Using dict comprehension
d = {x: x**2 for x in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# Valid key types (immutable only)
d = {
    "string_key": 1,
    100: "int_key",
    10.5: "float_key",
    True: "bool_key",
    (1, 2): "tuple_key"
}

# Values can be any type
d = {
    "list": [1, 2, 3],
    "dict": {"nested": "value"},
    "set": {1, 2, 3},
    "tuple": (1, 2, 3)
}
```

#### üìñ Extract/Read
```python
d = {"name": "Alice", "age": 30, "city": "NYC"}

# Single value by key
d["name"]              # "Alice" ‚ö†Ô∏è KeyError if not found
d.get("age")           # 30
d.get("salary")        # None (no error)
d.get("salary", 0)     # 0 (custom default)

# Check if key exists
"name" in d            # True
"salary" in d          # False

# Get all items
d.keys()               # dict_keys(['name', 'age', 'city'])
d.values()             # dict_values(['Alice', 30, 'NYC'])
d.items()              # dict_items([('name', 'Alice'), ('age', 30), ('city', 'NYC')])

# Iterate
for key in d:
    print(key, d[key])

for key, value in d.items():
    print(key, value)
```

#### ‚ûï Add
```python
d = {"a": 10, "b": 20}

# Add one key-value pair
d["c"] = 30                      # {"a": 10, "b": 20, "c": 30}
d.update({"d": 40})              # Add with update

# Add multiple key-value pairs
d.update({"e": 50, "f": 60})     # From dict
d.update([("g", 70), ("h", 80)]) # From list of tuples
```

#### ‚úèÔ∏è Modify/Replace
```python
d = {"a": 10, "b": 20, "c": 30}

# Replace one value
d["a"] = 100           # {"a": 100, "b": 20, "c": 30}

# Replace multiple values
d.update({"a": 111, "b": 222})  # {"a": 111, "b": 222, "c": 30}

# Rename key (move value to new key)
d["new_key"] = d.pop("c")       # {"a": 111, "b": 222, "new_key": 30}
```

#### üóëÔ∏è Remove
```python
d = {"a": 10, "b": 20, "c": 30, "d": 40}

# Remove by key
value = d.pop("b")     # Returns 20, removes "b"
del d["c"]             # Removes "c" (no return value)

# Remove with default (no error if missing)
value = d.pop("z", None)  # Returns None, no error

# Remove last inserted item (Python 3.7+)
key, value = d.popitem()  # Returns ("d", 40), removes it

# Remove all
d.clear()              # {}
```

#### üîß Other Operations
```python
d = {"a": 1, "b": 2, "c": 3}

# Copy
d2 = d.copy()          # Shallow copy

# Merge dictionaries
d1 = {"a": 1, "b": 2}
d2 = {"c": 3, "d": 4}
d3 = {**d1, **d2}      # {"a": 1, "b": 2, "c": 3, "d": 4}
d3 = d1 | d2           # Python 3.9+ (same result)

# Update with merge (modifies d1)
d1.update(d2)          # d1 now has all keys from d2

# Get with default creation
d.setdefault("e", 5)   # If "e" exists, return value; else add "e": 5

# Length
len(d)                 # Number of key-value pairs
```

### üéØ Real-World Use Cases

#### 1. User Profile/Data Storage
```python
user = {
    "id": 101,
    "username": "john_doe",
    "email": "john@example.com",
    "is_active": True,
    "roles": ["admin", "editor"]
}

print(f"Welcome, {user['username']}!")
```

#### 2. Configuration Settings
```python
config = {
    "database": {
        "host": "localhost",
        "port": 5432,
        "name": "mydb"
    },
    "debug": True,
    "max_connections": 100
}

db_host = config["database"]["host"]
```

#### 3. Word Frequency Counter
```python
text = "hello world hello python world"
words = text.split()

word_count = {}
for word in words:
    word_count[word] = word_count.get(word, 0) + 1

# {'hello': 2, 'world': 2, 'python': 1}
```

#### 4. Product Inventory with Prices
```python
inventory = {
    "laptop": {"price": 999, "stock": 5},
    "mouse": {"price": 25, "stock": 50},
    "keyboard": {"price": 75, "stock": 30}
}

# Update stock
inventory["laptop"]["stock"] -= 1

# Add new product
inventory["monitor"] = {"price": 299, "stock": 10}
```

#### 5. Student Records by ID
```python
students = {
    101: {"name": "Alice", "grade": "A"},
    102: {"name": "Bob", "grade": "B"},
    103: {"name": "Charlie", "grade": "A"}
}

# Lookup by ID (fast O(1))
student = students.get(102)
print(f"{student['name']} got {student['grade']}")
```

#### 6. API Response/JSON Data
```python
response = {
    "status": "success",
    "data": {
        "users": [
            {"id": 1, "name": "Alice"},
            {"id": 2, "name": "Bob"}
        ]
    },
    "timestamp": "2024-01-21"
}

users = response["data"]["users"]
```

#### 7. Caching/Memoization
```python
cache = {}

def expensive_function(n):
    if n in cache:
        return cache[n]  # Fast lookup
    
    result = n ** 2  # Expensive calculation
    cache[n] = result
    return result
```

### üìè Key Rules & Best Practices

‚úÖ **Use Dictionaries When:**
- You need key-value mapping
- You need fast lookups by key (O(1))
- You're working with JSON-like data
- You need to associate data with unique identifiers
- You're counting occurrences of items
- You need named access to values

‚ùå **Avoid Dictionaries When:**
- You only need values without keys ‚Üí Use List/Set
- You need ordered sequence by index ‚Üí Use List
- Keys are not unique or immutable ‚Üí Cannot use dict
- Memory is very limited (dicts use more memory)

‚ö†Ô∏è **Important Rules:**
- Keys MUST be immutable (str, int, float, bool, tuple)
- Keys MUST be unique (duplicates overwrite)
- Values can be any type (mutable or immutable)
- Ordered from Python 3.7+ (insertion order preserved)
- Fast O(1) lookup by key
- `d["key"]` raises KeyError if missing, `d.get("key")` returns None
- Empty dict is `{}`, empty set is `set()`

---

## üîÑ Type Casting Between Collections

### Complete Conversion Matrix

| From ‚Üì To ‚Üí | List | Tuple | Set | Dictionary |
|-------------|------|-------|-----|------------|
| **List** | `l` (itself) | `tuple(l)` | `set(l)` ‚úÖ | `dict(l)` ‚ö†Ô∏è |
| **Tuple** | `list(t)` ‚úÖ | `t` (itself) | `set(t)` ‚úÖ | `dict(t)` ‚ö†Ô∏è |
| **Set** | `list(s)` ‚úÖ | `tuple(s)` ‚úÖ | `s` (itself) | ‚ùå Not directly |
| **Dictionary** | `list(d)` keys<br>`list(d.values())`<br>`list(d.items())` | `tuple(d)` keys<br>`tuple(d.items())` | `set(d)` keys | `d` (itself) |

‚ö†Ô∏è **Note:** List/Tuple ‚Üí Dict requires list of tuples with 2 elements each

### 1Ô∏è‚É£ List Conversions

#### List ‚Üí Tuple
```python
l = [1, 2, 3, 4]
t = tuple(l)           # (1, 2, 3, 4)

# When to convert:
# - Make data immutable
# - Use as dictionary key
# - Pass to function expecting tuple
```

#### List ‚Üí Set
```python
l = [1, 2, 2, 3, 3, 4]
s = set(l)             # {1, 2, 3, 4} (duplicates removed)

# When to convert:
# - Remove duplicates
# - Fast membership testing
# - Set operations (union, intersection)

# ‚ùå FAILS if list contains mutable types:
l = [1, 2, [3, 4]]
# set(l)  # TypeError: unhashable type: 'list'
```

#### List ‚Üí Dictionary
```python
# ‚úÖ From list of tuples (each with 2 elements)
l = [("a", 1), ("b", 2), ("c", 3)]
d = dict(l)            # {"a": 1, "b": 2, "c": 3}

# ‚úÖ From list of lists (each with 2 elements)
l = [["name", "Alice"], ["age", 25]]
d = dict(l)            # {"name": "Alice", "age": 25}

# ‚ùå FAILS if elements don't have exactly 2 items:
l = [(1, 2, 3)]
# dict(l)  # ValueError: dictionary update sequence element #0 has length 3; 2 is required

# When to convert:
# - Transform paired data into key-value mapping
# - Create lookup table from data
```

### 2Ô∏è‚É£ Tuple Conversions

#### Tuple ‚Üí List
```python
t = (1, 2, 3, 4)
l = list(t)            # [1, 2, 3, 4]

# When to convert:
# - Need to modify data
# - Need to use list methods (append, extend, etc.)
# - Need to sort or reverse
```

#### Tuple ‚Üí Set
```python
t = (1, 2, 2, 3, 3, 4)
s = set(t)             # {1, 2, 3, 4}

# When to convert:
# - Remove duplicates
# - Fast membership testing
```

#### Tuple ‚Üí Dictionary
```python
# Same as List ‚Üí Dictionary
t = (("a", 1), ("b", 2))
d = dict(t)            # {"a": 1, "b": 2}
```

### 3Ô∏è‚É£ Set Conversions

#### Set ‚Üí List
```python
s = {3, 1, 4, 2}
l = list(s)            # [1, 2, 3, 4] (order not guaranteed!)

# When to convert:
# - Need indexing/slicing
# - Need to sort (then convert)
# - Need to preserve order

# Sort after converting
l = sorted(s)          # [1, 2, 3, 4] (guaranteed order)
```

#### Set ‚Üí Tuple
```python
s = {3, 1, 4, 2}
t = tuple(s)           # Order not guaranteed

# When to convert:
# - Need immutable unordered collection
# - Use as dictionary key
```

#### Set ‚Üí Dictionary
```python
# ‚ùå No direct conversion (sets don't have key-value pairs)

# ‚úÖ Workarounds:
s = {1, 2, 3}

# Create dict with set values as keys
d = {item: None for item in s}  # {1: None, 2: None, 3: None}
d = dict.fromkeys(s)             # Same result

# Create dict with index as key
d = {i: item for i, item in enumerate(s)}  # {0: 1, 1: 2, 2: 3}
```

### 4Ô∏è‚É£ Dictionary Conversions

#### Dictionary ‚Üí List
```python
d = {"a": 1, "b": 2, "c": 3}

# Keys only
l = list(d)            # ["a", "b", "c"]
l = list(d.keys())     # ["a", "b", "c"]

# Values only
l = list(d.values())   # [1, 2, 3]

# Key-value pairs as tuples
l = list(d.items())    # [("a", 1), ("b", 2), ("c", 3)]

# When to convert:
# - Need to iterate with index
# - Need to sort keys/values
# - Need to use list methods
```

#### Dictionary ‚Üí Tuple
```python
d = {"a": 1, "b": 2}

# Keys only
t = tuple(d)           # ("a", "b")

# Key-value pairs
t = tuple(d.items())   # (("a", 1), ("b", 2))

# When to convert:
# - Make keys immutable
# - Use as another dict key
```

#### Dictionary ‚Üí Set
```python
d = {"a": 1, "b": 2, "c": 3}

# Keys only
s = set(d)             # {"a", "b", "c"}
s = set(d.keys())      # {"a", "b", "c"}

# Values only
s = set(d.values())    # {1, 2, 3}

# When to convert:
# - Get unique keys/values
# - Fast membership testing on keys
# - Set operations on keys
```

### üéØ Common Conversion Patterns

#### Pattern 1: Remove Duplicates from List (Preserve Some Order)
```python
# Basic (order not guaranteed)
l = [1, 2, 2, 3, 3, 4]
unique = list(set(l))  # [1, 2, 3, 4]

# Preserve order (Python 3.7+)
unique = list(dict.fromkeys(l))  # [1, 2, 3, 4] (order preserved)
```

#### Pattern 2: Merge Two Lists Without Duplicates
```python
l1 = [1, 2, 3]
l2 = [2, 3, 4, 5]

# Using sets
merged = list(set(l1) | set(l2))  # [1, 2, 3, 4, 5]
# OR
merged = list(set(l1 + l2))       # [1, 2, 3, 4, 5]
```

#### Pattern 3: Count Occurrences (List ‚Üí Dict)
```python
items = ["a", "b", "a", "c", "b", "a"]

# Manual counting
counts = {}
for item in items:
    counts[item] = counts.get(item, 0) + 1
# {"a": 3, "b": 2, "c": 1}

# Using Counter (from collections)
from collections import Counter
counts = dict(Counter(items))
```

#### Pattern 4: Dict to Sorted List
```python
d = {"c": 3, "a": 1, "b": 2}

# Sort by keys
sorted_items = sorted(d.items())  # [("a", 1), ("b", 2), ("c", 3)]

# Sort by values
sorted_items = sorted(d.items(), key=lambda x: x[1])
# [("a", 1), ("b", 2), ("c", 3)]
```

#### Pattern 5: Create Lookup Dictionary from Lists
```python
keys = ["a", "b", "c"]
values = [1, 2, 3]

# Using zip
d = dict(zip(keys, values))  # {"a": 1, "b": 2, "c": 3}
```

### ‚ö†Ô∏è Conversion Rules & Gotchas

**1. Set Conversion Rules:**
```python
# ‚úÖ Only immutable types in set
s = {1, 2, (3, 4)}     # OK

# ‚ùå Cannot have mutable types
# s = {1, 2, [3, 4]}   # TypeError: unhashable type: 'list'
# s = {1, 2, {3, 4}}   # TypeError: unhashable type: 'set'
```

**2. Dict Conversion Rules:**
```python
# ‚úÖ Each element must have exactly 2 items
l = [("a", 1), ("b", 2)]
d = dict(l)  # OK

# ‚ùå Wrong number of items
# l = [("a", 1, 2)]
# dict(l)  # ValueError
```

**3. Order Preservation:**
```python
# Lists and Tuples preserve order
l = [3, 1, 4, 2]
t = tuple(l)  # (3, 1, 4, 2) - order preserved

# Sets don't preserve order
s = set(l)    # {1, 2, 3, 4} - order changed
l2 = list(s)  # [1, 2, 3, 4] - don't rely on this order!
```

**4. Boolean/Integer Overlap:**
```python
# True == 1, False == 0 in sets
s = {0, 1, False, True}
print(s)  # {0, 1} (False absorbed by 0, True absorbed by 1)

s = {False, True}
print(s)  # {False, True}

s = {0, 1}
print(s)  # {0, 1}
```

---

## üéØ When to Use Which Collection

### Decision Tree

```
Do you need key-value pairs?
‚îú‚îÄ YES ‚Üí Dictionary {}
‚îî‚îÄ NO
   ‚îî‚îÄ Do you need unique values only?
      ‚îú‚îÄ YES ‚Üí Set {}
      ‚îî‚îÄ NO
         ‚îî‚îÄ Will the data change?
            ‚îú‚îÄ YES ‚Üí List []
            ‚îî‚îÄ NO ‚Üí Tuple ()
```

### Detailed Decision Guide

| Scenario | Use | Reason |
|----------|-----|--------|
| Shopping cart items | **List** | Order matters, duplicates allowed, need to modify |
| GPS coordinates | **Tuple** | Fixed position, shouldn't change |
| Unique email list | **Set** | No duplicates, fast lookup |
| User profile data | **Dictionary** | Key-value mapping, named access |
| Task queue (FIFO) | **List** | Order preserved, can pop from start |
| RGB color values | **Tuple** | Fixed values, immutable |
| Active user IDs | **Set** | Unique IDs, fast membership test |
| Product inventory | **Dictionary** | Product ID ‚Üí details mapping |
| Student grades | **List** | Order matters, can have duplicate values |
| Database record | **Tuple** | Immutable row data |
| Tags/categories | **Set** | Unique tags, no order needed |
| Configuration | **Dictionary** | Named settings |

### Performance Comparison

| Operation | List | Tuple | Set | Dictionary |
|-----------|------|-------|-----|------------|
| Access by index/key | O(1) | O(1) | N/A | O(1) |
| Search (`in`) | O(n) | O(n) | O(1) | O(1) keys |
| Add element | O(1) end | N/A | O(1) | O(1) |
| Remove element | O(n) | N/A | O(1) | O(1) |
| Memory usage | Medium | Low | Medium | High |
| Iteration speed | Fast | Fastest | Fast | Fast |

---

## üìã Quick Syntax Reference

### Creation
```python
l = [1, 2, 3]          # List
t = (1, 2, 3)          # Tuple
s = {1, 2, 3}          # Set
d = {"a": 1, "b": 2}   # Dictionary

# Empty
l = [] or list()
t = () or tuple()
s = set()              # NOT {}
d = {} or dict()
```

### Access
```python
l[0], l[-1], l[1:3]    # List: indexing, slicing
t[0], t[-1], t[1:3]    # Tuple: indexing, slicing
# s[0]                 # Set: ‚ùå No indexing
d["key"], d.get("key") # Dict: by key
```

### Add
```python
l.append(x)            # List: one at end
l.extend([x, y])       # List: multiple at end
# t.append(x)          # Tuple: ‚ùå Immutable
s.add(x)               # Set: one element
s.update([x, y])       # Set: multiple elements
d["key"] = value       # Dict: one pair
d.update({"k": v})     # Dict: multiple pairs
```

### Remove
```python
l.remove(x), l.pop()   # List
# t.remove(x)          # Tuple: ‚ùå Immutable
s.remove(x), s.pop()   # Set
d.pop("key"), del d["key"]  # Dict
```

### Check Membership
```python
x in l                 # List: O(n)
x in t                 # Tuple: O(n)
x in s                 # Set: O(1) ‚ö° Fast
"key" in d             # Dict: O(1) ‚ö° Fast
```

### Conversions
```python
list(x)                # ‚Üí List
tuple(x)               # ‚Üí Tuple
set(x)                 # ‚Üí Set
dict(x)                # ‚Üí Dict (needs pairs)
```

---

## üéì Summary & Best Practices

### Key Takeaways

1. **Lists**: Use for ordered, mutable collections with possible duplicates
2. **Tuples**: Use for ordered, immutable collections (data protection)
3. **Sets**: Use for unique values and fast membership testing
4. **Dictionaries**: Use for key-value mappings and fast lookups

### Common Mistakes to Avoid

‚ùå Using `{}` for empty set (it's a dict!)
‚ùå Trying to modify tuples
‚ùå Putting mutable types in sets
‚ùå Using mutable types as dict keys
‚ùå Forgetting that sets are unordered
‚ùå Using `remove()` without checking existence

### Best Practices

‚úÖ Use `list` for sequences that change
‚úÖ Use `tuple` for fixed data and function returns
‚úÖ Use `set` for uniqueness and fast lookups
‚úÖ Use `dict` for structured data with named fields
‚úÖ Use `get()` with dicts to avoid KeyErrors
‚úÖ Use `discard()` with sets to avoid KeyErrors
‚úÖ Convert to set to remove duplicates
‚úÖ Use comprehensions for transformations
‚úÖ Choose the right collection for your use case

---

**End of Guide** üéâ
