### üîß Troubleshooting
10. [Debugging Guide](#debugging-guide)
11. [Common Errors & Solutions](#common-errors-solutions)
12. [Testing Practices](#testing-practices)
## Best Practices Checklist
## Testing Practices

## Debugging Guide

### Enable SQL Logging

```python
# Method 1: At engine creation
engine = create_engine(
    DATABASE_URL,
    echo=True,  # Logs all SQL statements
    echo_pool="debug"  # Logs connection pool events
)

# Method 2: Via logging module
import logging
logging.basicConfig()
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)
```

### Debug Session State

```python
def debug_session_info(db: Session):
    """Print session state for debugging"""
    print(f"Session ID: {id(db)}")
    print(f"Is active: {db.is_active}")
    print(f"Is dirty (modified): {len(db.dirty)} objects")
    print(f"Is new (added): {len(db.new)} objects")
    print(f"Is deleted: {len(db.deleted)} objects")
    
    # Show modified objects
    for obj in db.dirty:
        print(f"Modified: {obj}")
    
    # Show new objects
    for obj in db.new:
        print(f"New: {obj}")
```

### Monitor Connection Pool

```python
from sqlalchemy import event

@event.listens_for(engine, "connect")
def receive_connect(dbapi_conn, connection_record):
    print(f"New connection: {id(dbapi_conn)}")

@event.listens_for(engine, "close")
def receive_close(dbapi_conn, connection_record):
    print(f"Closed connection: {id(dbapi_conn)}")

@event.listens_for(engine, "checkout")
def receive_checkout(dbapi_conn, connection_record, connection_proxy):
    print(f"Connection checked out from pool: {id(dbapi_conn)}")

@event.listens_for(engine, "checkin")
def receive_checkin(dbapi_conn, connection_record):
    print(f"Connection checked in to pool: {id(dbapi_conn)}")
```

### Check Database Connections

```python
# For PostgreSQL
@app.get("/debug/connections")
def get_active_connections(db: Session = Depends(get_database_session)):
    from sqlalchemy import text
    result = db.execute(text("""
        SELECT count(*) 
        FROM pg_stat_activity 
        WHERE datname = current_database()
    """))
    return {"active_connections": result.scalar()}
```

---

## Common Errors & Solutions

### Error 1: "This Session's transaction has been rolled back"

**Cause:** Trying to use session after an error without rollback

```python
# ‚ùå WRONG
try:
    db.query(Product).all()
    # Error occurs
except:
    db.query(User).all()  # Session still in bad state!

# ‚úÖ CORRECT
try:
    db.query(Product).all()
except:
    db.rollback()  # Reset session
    db.query(User).all()  # Now it works
```

### Error 2: "QueuePool limit exceeded"

**Cause:** Too many connections, not closing sessions

```python
# ‚ùå WRONG
@app.get("/products")
def get_products():
    db = SessionLocal()
    products = db.query(Product).all()
    # Forgot to close!
    return products

# ‚úÖ CORRECT
@app.get("/products")
def get_products(db: Session = Depends(get_database_session)):
    return db.query(Product).all()
    # Automatically closed by dependency
```

### Error 3: "Can't reconnect until invalid transaction is rolled back"

**Cause:** Connection died during transaction

```python
# ‚úÖ SOLUTION: Enable pool_pre_ping
engine = create_engine(
    DATABASE_URL,
    pool_pre_ping=True  # Test connection before use
)
```

### Error 4: "Instance is not bound to a Session"

**Cause:** Trying to access relationship after session closed

```python
# ‚ùå WRONG
@app.get("/products/{id}")
def get_product(id: int, db: Session = Depends(get_database_session)):
    product = db.query(Product).filter(Product.id == id).first()
    return product
# Session closed here, then FastAPI tries to serialize product.category
# Error! Relationship not loaded

# ‚úÖ CORRECT - Method 1: Eager load
from sqlalchemy.orm import joinedload

@app.get("/products/{id}")
def get_product(id: int, db: Session = Depends(get_database_session)):
    product = db.query(Product).options(
        joinedload(Product.category)
    ).filter(Product.id == id).first()
    return product

# ‚úÖ CORRECT - Method 2: Use Pydantic schemas
from pydantic import BaseModel

class ProductResponse(BaseModel):
    id: int
    name: str
    price: float
    
    class Config:
        from_attributes = True

@app.get("/products/{id}", response_model=ProductResponse)
def get_product(id: int, db: Session = Depends(get_database_session)):
    product = db.query(Product).filter(Product.id == id).first()
    return product  # Pydantic converts while session is active
```

### Error 5: "DetachedInstanceError"

**Cause:** Accessing object after session closed

```python
# ‚ùå WRONG
def get_product_name(product_id: int):
    db = SessionLocal()
    product = db.query(Product).get(product_id)
    db.close()
    return product.name  # Error! Object detached from session

# ‚úÖ CORRECT - Access while session open
def get_product_name(product_id: int):
    db = SessionLocal()
    try:
        product = db.query(Product).get(product_id)
        name = product.name  # Access before close
        return name
    finally:
        db.close()
```

---

## Testing Practices

### Test Database Setup

**Option 1: In-Memory SQLite (Fast, Isolated)**

```python
# conftest.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from fastapi.testclient import TestClient

from database.session import SessionLocal
from models.base import Base
from main import app
from dependencies.database import get_database_session

# Test database URL (in-memory)
TEST_DATABASE_URL = "sqlite:///:memory:"

# Create test engine
test_engine = create_engine(
    TEST_DATABASE_URL,
    connect_args={"check_same_thread": False}  # For SQLite only
)

# Create test session factory
TestSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)

@pytest.fixture(scope="function")
def test_db():
    """Create fresh database for each test"""
    # Create all tables
    Base.metadata.create_all(bind=test_engine)
    
    # Create session
    db = TestSessionLocal()
    
    try:
        yield db
    finally:
        db.close()
        # Drop all tables after test
        Base.metadata.drop_all(bind=test_engine)

@pytest.fixture(scope="function")
def client(test_db):
    """FastAPI test client with test database"""
    def override_get_db():
        try:
            yield test_db
        finally:
            pass  # Don't close, fixture handles it
    
    app.dependency_overrides[get_database_session] = override_get_db
    
    with TestClient(app) as test_client:
        yield test_client
    
    app.dependency_overrides.clear()
```

**Option 2: Separate Test Database (More Realistic)**

```python
# conftest.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# Separate test database
TEST_DATABASE_URL = "postgresql://postgres:password@localhost:5432/test_db"

test_engine = create_engine(TEST_DATABASE_URL)
TestSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)

@pytest.fixture(scope="session", autouse=True)
def setup_test_database():
    """Create tables once for all tests"""
    Base.metadata.create_all(bind=test_engine)
    yield
    Base.metadata.drop_all(bind=test_engine)

@pytest.fixture(scope="function")
def test_db():
    """Rollback after each test"""
    connection = test_engine.connect()
    transaction = connection.begin()
    db = TestSessionLocal(bind=connection)
    
    yield db
    
    db.close()
    transaction.rollback()
    connection.close()
```

### Writing Tests

**Test CRUD Operations:**

```python
# test_products.py
import pytest
from models.product import Product
from schemas.product import ProductCreate

def test_create_product(client, test_db):
    """Test creating a product"""
    response = client.post(
        "/products",
        json={"name": "Test Product", "price": 29.99, "quantity": 10}
    )
    
    assert response.status_code == 200
    data = response.json()
    assert data["name"] == "Test Product"
    assert data["price"] == 29.99
    
    # Verify in database
    db_product = test_db.query(Product).filter(Product.name == "Test Product").first()
    assert db_product is not None
    assert db_product.quantity == 10

def test_get_product(client, test_db):
    """Test retrieving a product"""
    # Create test data
    product = Product(name="Test Product", price=19.99, quantity=5)
    test_db.add(product)
    test_db.commit()
    test_db.refresh(product)
    
    # Test endpoint
    response = client.get(f"/products/{product.id}")
    assert response.status_code == 200
    
    data = response.json()
    assert data["id"] == product.id
    assert data["name"] == "Test Product"

def test_update_product(client, test_db):
    """Test updating a product"""
    # Create test data
    product = Product(name="Old Name", price=10.00, quantity=1)
    test_db.add(product)
    test_db.commit()
    test_db.refresh(product)
    
    # Update
    response = client.put(
        f"/products/{product.id}",
        json={"name": "New Name", "price": 15.00}
    )
    assert response.status_code == 200
    
    # Verify
    test_db.refresh(product)
    assert product.name == "New Name"
    assert product.price == 15.00

def test_delete_product(client, test_db):
    """Test deleting a product"""
    # Create test data
    product = Product(name="To Delete", price=5.00, quantity=1)
    test_db.add(product)
    test_db.commit()
    product_id = product.id
    
    # Delete
    response = client.delete(f"/products/{product_id}")
    assert response.status_code == 200
    
    # Verify deleted
    deleted_product = test_db.query(Product).filter(Product.id == product_id).first()
    assert deleted_product is None
```

**Test Error Handling:**

```python
def test_get_nonexistent_product(client):
    """Test 404 for nonexistent product"""
    response = client.get("/products/99999")
    assert response.status_code == 404
    assert response.json()["detail"] == "Product not found"

def test_create_invalid_product(client):
    """Test validation errors"""
    response = client.post(
        "/products",
        json={"name": "Test"}  # Missing required price field
    )
    assert response.status_code == 422  # Validation error
```

**Test Database Constraints:**

```python
def test_unique_constraint(test_db):
    """Test database unique constraint"""
    # Create first product
    product1 = Product(name="Unique", price=10.00)
    test_db.add(product1)
    test_db.commit()
    
    # Try to create duplicate (if unique constraint exists)
    from sqlalchemy.exc import IntegrityError
    
    product2 = Product(name="Unique", price=20.00)
    test_db.add(product2)
    
    with pytest.raises(IntegrityError):
        test_db.commit()
    
    test_db.rollback()  # Clean up
```

**Test Transactions:**

```python
def test_rollback_on_error(test_db):
    """Test that errors trigger rollback"""
    initial_count = test_db.query(Product).count()
    
    try:
        product = Product(name="Test", price=10.00)
        test_db.add(product)
        test_db.flush()  # Send to database but don't commit
        
        # Simulate error
        raise ValueError("Simulated error")
        
    except ValueError:
        test_db.rollback()
    
    # Verify nothing was saved
    final_count = test_db.query(Product).count()
    assert final_count == initial_count
```

### Testing Best Practices

**1. Isolate Tests**
```python
# Use function scope for database fixtures
@pytest.fixture(scope="function")  # New DB for each test
def test_db():
    # Setup
    yield db
    # Teardown
```

**2. Use Factories for Test Data**
```python
# factories.py
from faker import Faker
from models.product import Product

fake = Faker()

class ProductFactory:
    @staticmethod
    def create(**kwargs):
        defaults = {
            "name": fake.word(),
            "price": fake.pyfloat(min_value=1, max_value=1000, right_digits=2),
            "quantity": fake.random_int(min=0, max=100)
        }
        defaults.update(kwargs)
        return Product(**defaults)

# In tests:
def test_with_factory(test_db):
    product = ProductFactory.create(name="Specific Name")
    test_db.add(product)
    test_db.commit()
```

**3. Test Database Migrations**
```python
# If using Alembic
def test_migration_up_down():
    """Test migrations work both ways"""
    from alembic import command
    from alembic.config import Config
    
    config = Config("alembic.ini")
    
    # Upgrade
    command.upgrade(config, "head")
    
    # Downgrade
    command.downgrade(config, "base")
    
    # Upgrade again
    command.upgrade(config, "head")
```

---
