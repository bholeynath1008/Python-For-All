### ðŸ’¡ Best Practices
7. [Best Practices Checklist](#best-practices-checklist)
8. [Common Patterns](#common-patterns)
9. [Performance Optimization](#performance-optimization)

## Best Practices Checklist

### âœ… Mandatory Practices

#### 1. One Engine Per Application
```python
# âœ… CORRECT: Create once at module level
# database/engine.py
engine = create_engine(DATABASE_URL)

# âŒ WRONG: Creating multiple engines
def get_engine():
    return create_engine(DATABASE_URL)  # New engine each time!
```

#### 2. Always Close Sessions
```python
# âœ… CORRECT: Using dependency with finally
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()  # Always closes

# âŒ WRONG: Forgetting to close
def get_db():
    return SessionLocal()  # Never closed! Memory leak!
```

#### 3. Handle Rollbacks
```python
# âœ… CORRECT: Rollback on error
try:
    db.add(new_item)
    db.commit()
except Exception:
    db.rollback()  # Undo changes
    raise

# âŒ WRONG: No rollback
try:
    db.add(new_item)
    db.commit()
except Exception:
    raise  # Session left in bad state!
```

#### 4. Use autocommit=False
```python
# âœ… CORRECT: Explicit commits
SessionLocal = sessionmaker(autocommit=False, bind=engine)

# Route:
db.add(item)
db.commit()  # We control when to save

# âŒ WRONG: autocommit=True (dangerous)
SessionLocal = sessionmaker(autocommit=True, bind=engine)
# Changes saved immediately, can't rollback!
```

#### 5. Enable Connection Testing
```python
# âœ… CORRECT: Test connections before use
engine = create_engine(
    DATABASE_URL,
    pool_pre_ping=True  # Prevents stale connections
)

# âŒ WRONG: No testing
engine = create_engine(DATABASE_URL)
# May use stale/broken connections
```

---

## Common Patterns

### Pattern 1: CRUD Operations

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from dependencies.database import get_database_session
from models.product import Product
from schemas.product import ProductCreate, ProductUpdate

router = APIRouter()

# CREATE
@router.post("/products")
def create_product(
    product: ProductCreate,
    db: Session = Depends(get_database_session)
):
    db_product = Product(**product.dict())
    db.add(db_product)
    db.commit()
    db.refresh(db_product)  # Get ID and defaults
    return db_product

# READ (Single)
@router.get("/products/{product_id}")
def get_product(
    product_id: int,
    db: Session = Depends(get_database_session)
):
    product = db.query(Product).filter(Product.id == product_id).first()
    if not product:
        raise HTTPException(status_code=404, detail="Product not found")
    return product

# READ (List)
@router.get("/products")
def list_products(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_database_session)
):
    products = db.query(Product).offset(skip).limit(limit).all()
    return products

# UPDATE
@router.put("/products/{product_id}")
def update_product(
    product_id: int,
    product_update: ProductUpdate,
    db: Session = Depends(get_database_session)
):
    db_product = db.query(Product).filter(Product.id == product_id).first()
    if not db_product:
        raise HTTPException(status_code=404, detail="Product not found")
    
    for key, value in product_update.dict(exclude_unset=True).items():
        setattr(db_product, key, value)
    
    db.commit()
    db.refresh(db_product)
    return db_product

# DELETE
@router.delete("/products/{product_id}")
def delete_product(
    product_id: int,
    db: Session = Depends(get_database_session)
):
    db_product = db.query(Product).filter(Product.id == product_id).first()
    if not db_product:
        raise HTTPException(status_code=404, detail="Product not found")
    
    db.delete(db_product)
    db.commit()
    return {"message": "Product deleted"}
```

### Pattern 2: Complex Queries

```python
# Filtering
products = db.query(Product).filter(
    Product.price > 100,
    Product.quantity > 0
).all()

# Ordering
products = db.query(Product).order_by(Product.price.desc()).all()

# Limiting
products = db.query(Product).limit(10).all()

# Pagination
page = 1
page_size = 20
products = db.query(Product).offset((page - 1) * page_size).limit(page_size).all()

# Count
total = db.query(Product).count()

# Select specific columns
results = db.query(Product.name, Product.price).all()

# Joins (with relationships defined)
from sqlalchemy.orm import joinedload
products = db.query(Product).options(joinedload(Product.category)).all()
```

### Pattern 3: Bulk Operations

```python
# Bulk insert
products = [
    Product(name="Item 1", price=10),
    Product(name="Item 2", price=20),
    Product(name="Item 3", price=30),
]
db.bulk_save_objects(products)
db.commit()

# Bulk update
db.query(Product).filter(Product.price < 10).update(
    {"price": 15},
    synchronize_session=False
)
db.commit()

# Bulk delete
db.query(Product).filter(Product.quantity == 0).delete()
db.commit()
```

---

## Performance Optimization

### 1. Index Strategic Columns

```python
class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)  # Frequently searched
    username = Column(String, index=True)  # Frequently searched
    full_name = Column(String)  # Not indexed (rarely searched alone)
    
    # Composite index for common query patterns
    __table_args__ = (
        Index('idx_user_email_username', 'email', 'username'),
    )
```

### 2. Use Connection Pooling Wisely

```python
# For small apps (< 100 concurrent users)
engine = create_engine(
    DATABASE_URL,
    pool_size=5,
    max_overflow=10
)

# For medium apps (100-1000 concurrent users)
engine = create_engine(
    DATABASE_URL,
    pool_size=20,
    max_overflow=20
)

# For large apps (1000+ concurrent users)
engine = create_engine(
    DATABASE_URL,
    pool_size=50,
    max_overflow=50,
    pool_recycle=3600  # 1 hour
)
```

### 3. Optimize Queries

```python
# âŒ N+1 Query Problem
products = db.query(Product).all()
for product in products:
    print(product.category.name)  # Separate query for each product!

# âœ… Eager Loading (Single Query)
from sqlalchemy.orm import joinedload
products = db.query(Product).options(
    joinedload(Product.category)
).all()

# âœ… Select Only Needed Columns
# Instead of loading entire objects
results = db.query(Product.id, Product.name).all()

# âœ… Use Pagination
def get_products_paginated(db: Session, page: int = 1, size: int = 50):
    return db.query(Product).offset((page - 1) * size).limit(size).all()
```

### 4. Monitor Query Performance

```python
# Enable query logging in development
engine = create_engine(
    DATABASE_URL,
    echo=True,  # See all queries
    echo_pool="debug"  # See pool events
)

# Use EXPLAIN for slow queries
from sqlalchemy import text
result = db.execute(text("EXPLAIN ANALYZE SELECT * FROM products WHERE price > 100"))
print(result.fetchall())
```

---
